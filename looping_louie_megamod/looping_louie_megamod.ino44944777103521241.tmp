#include <Led.h> // Klasse Pin erzeugt für einen Pin eine Led, die dann an- und ausgeschaltet werden kann
#include <Motor.h> // Klasse Motor erzeugt für zwei Pins einen Motor, dessen Geschwindigkeit und maximale Geschwindigkeit kontrolliert werden kann
#include <Button.h> // Klasse Button erzeugt für einen Pin einen Button, der gedrückt und losgelassen werden kann
//#include <Stoppuhr.h>
#include <limits.h>
// Überprüft, ob für eine gemerkte Zeit eine gewisse Pause verstrichen ist, und setzt in dem Fall die gemerkte Zeit auf die aktuelle
class Stoppuhr {
  public:
    Stoppuhr(unsigned long minimale_pause) {
      _minimale_pause = minimale_pause;
    };
    boolean ist_abgelaufen() {
      return (millis() - _letzter_stand) >= _minimale_pause;
    };
    unsigned long laeuft_bereits() {
      return millis() - _letzter_stand;
    }
    void reset() {
      _letzter_stand = millis();
    }
  private:
    unsigned long _letzter_stand = millis();
    unsigned long _minimale_pause;
};


/* 
 *  Allgemeine Funktionen
 */
 
// Gibt die Arraylänge zurück
// https://arduino.land/FAQ/content/6/29/en/how-to-get-the-size-of-an-array.html
#define arr_len( x )  ( sizeof( x ) / sizeof( *x ) ) // Gibt die Länge eines Arrays zurück

// Zwingt den Wert n ins geschlossene Intervall [lower, upper]
// http://stackoverflow.com/a/9324086
template <typename T> T clip(const T& n, const T& lower, const T& upper) {
  return max(lower, min(n, upper));
}

// This allows you to write succinct code like
// Serial << "My name is " << name << " and I am " << age << " years old.";
// http://playground.arduino.cc/Main/StreamingOutput
template<class T> inline Print &operator <<(Print &obj, T arg) {
  obj.print(arg);
  return obj;
}

/*// Prüft, ob ein Wert im geschlossenen Intervall [low, high] ist
// http://stackoverflow.com/a/9255906
template <typename T> bool isInBounds(const T& value, const T& low, const T& high) {
  return !(value < low) && !(high < value);
}*/


/* 
 *  Globale Variablen
 */

// Pinbelegung
const Led leds[] = {Led(9), Led(10), Led(11)};
const unsigned int led_pins_count = arr_len(leds); // Anzahl der LEDs für späteren Gebrauch speichern
const Motor motor(6, 5);

// Konstanten und anderer Kram
unsigned int spielmodus = 0;
unsigned long laufzeit_spielmodus_beginn = 0;
unsigned int anzahl_spielmodi = 0;

// Einstellungen
const boolean debugging = true;


/* 
 *  LED-bezogene Funktionen
 */

// Setzt alle LEDs auf an (true) oder aus (false)
inline void alle_leds(boolean led_status) {
  for (Led led: leds) {
    led.status_set(led_status);
  }
}

// Lässt alle LEDs für eine bestimmte Anzahl (count), Dauer (time_on) und Pausendauer (time_off) blinken
inline void alle_leds_blinken(int count = 3, int time_on = 120, int time_off = 120) {
  for (int i = 0; i < count; i++) {
    alle_leds(1);
    delay(time_on);
    alle_leds(0);
    delay(time_off);
  }
}


/* 
 *  Spielmodi
 */

// Funktionen für die Laufzeit des aktuellen Spielmodus
#define laufzeit_spielmodus_set()  ( laufzeit_spielmodus_beginn = millis() ) // Setzt die Startzeit des aktuellen Spielmodus auf die aktuelle Laufzeit des Programms
#define laufzeit_spielmodus_get()  ( millis() - laufzeit_spielmodus_beginn ) // Gibt die Laufzeit des aktuellen Spielmodus

// Hier werden die Spielmodi programmiert. Für jeden Spielmodus gibt es im Array eine Funktion, die die aktuelle Geschwindigkeit bestimmt.
// Der Teil hier ist noch dreckig und sollte aufgeräumt werden, ist vor Niels' Party schnell entstanden. Das könnte vielleicht in die Funktion von Spielmodus 3, und die Startwerte für _ges und _rueckwaerts könnten auf Infinity gesetzt werden?
const unsigned int modus4_laenge_ges_min = 2000;
const unsigned int modus4_laenge_ges_max = 7000;
const unsigned int modus4_laenge_rueckwaerts_min = 220;
const unsigned int modus4_laenge_rueckwaerts_max = 400;
unsigned int modus4_laenge_ges = modus4_laenge_ges_min + (rand() % (int)(modus4_laenge_ges_max - modus4_laenge_ges_min + 1));
unsigned int modus4_laenge_rueckwaerts = modus4_laenge_rueckwaerts_min + (rand() % (int)(modus4_laenge_rueckwaerts_max - modus4_laenge_rueckwaerts_min + 1));

typedef float (*Spielmodus) ();
Spielmodus spielmodi[] = {
  []() -> float {
    // Nach einer festen Zeit einen Spieler angreifen (auf einer Stelle hin und her)
    const unsigned int vorwaerts = 3000; // So viele ms wird zunächst normal gefahren (s.u.)
    const unsigned int rueckwaerts = 3000; // Dann wird auf der Stelle hin- und hergefahren
    const unsigned int hinundher = 3; // So oft wird hin- und hergefahren
    const float geschwindigkeit = 0.6f; // Geschwindigkeit beim Vor- und Rückwärtsfahren (bei Vollgas rutscht der Arm durch)

    // Stoppuhren erstellen
    static Stoppuhr stoppuhr_hinundher_vorwaerts(vorwaerts);
    static Stoppuhr stoppuhr_hinundher_rueckwaerts(vorwaerts + rueckwaerts);
    
    if (!stoppuhr_hinundher_vorwaerts.ist_abgelaufen()) {
      // Eine Zeit lang normal fahren (hier kommt kein Code hin)
      Serial.println("-->");
    } else if (!stoppuhr_hinundher_rueckwaerts.ist_abgelaufen()) {
      // Dann auf einer Stelle hin- und herfahren
      const float oscillator = (((stoppuhr_hinundher_rueckwaerts.laeuft_bereits() - stoppuhr_hinundher_vorwaerts.laeuft_bereits()) % ((rueckwaerts)/hinundher)) / ((static_cast<float>(rueckwaerts))/hinundher) - 0.5f) * 2; // oscillator läuft linear zwischen 1.0f und -1.0f hin- und her
      return (oscillator < 0 ? floor(oscillator) : ceil(oscillator)) * geschwindigkeit; // Rück- oder vorwärts mit oben eingestellter Geschwindigkeit
      Serial.println("<--");
    } else {
      // Ein Zyklus ist rum, Stoppuhren neu starten
      stoppuhr_hinundher_vorwaerts.reset();
      stoppuhr_hinundher_rueckwaerts.reset();
    }
    return 0.7f;
  },
  []() -> float {
    // Wie Spielmodus 2 fahren, nur ab und zu ein Stück rückwärts
    unsigned long zeit_vergangen = millis() - zuletzt_ausgefuehrt__chaos_rueckwaerts;
    if (zeit_vergangen <= modus4_laenge_ges - modus4_laenge_rueckwaerts) {
      // Wird nur gebraucht, damit unten zur richtigen Zeit ins else gesprungen wird
    } else if (zeit_vergangen <= modus4_laenge_ges) {
      // Rückwärts fahren, zufällig schnell
      const float low = -1.0f;
      const float high = -0.3f;
      return low + static_cast <float> (rand()) /(static_cast <float> (RAND_MAX/(high-low)));
    } else {
      // Ein Zyklus ist rum, Timer neu starten und nächsten Anschlag planen
      zuletzt_ausgefuehrt__chaos_rueckwaerts = millis();
      modus4_laenge_ges = modus4_laenge_ges_min + (rand() % (int)(modus4_laenge_ges_max - modus4_laenge_ges_min + 1));
      modus4_laenge_rueckwaerts = modus4_laenge_rueckwaerts_min + (rand() % (int)(modus4_laenge_rueckwaerts_max - modus4_laenge_rueckwaerts_min + 1));
    }
    return spielmodi[2](); // Spielmodus 2
    
    // Vollgas
    return 1.0f;
  },
  []() -> float {
    // Zwischen zwei Geschwindigkeiten oszillieren
    // Dieser Spielmodus wird auch in Spielmodus 3 benutzt, ggf. also vorm Verändern dorthin kopieren
    static const float pi = static_cast<float>(atan(1)*4); // http://stackoverflow.com/a/1727886
    const float low = 0.24f;
    const float high = 1.0f;
    return clip(static_cast<float>((high-low)/2+low + sin(laufzeit_spielmodus_get()/(2*pi*130))*((high-low)/2)), low, high);
  },
  []() -> float {
    static unsigned long zuletzt_ausgefuehrt__rauswurf = 0; // hier eigentlich ULONG_MAX?
    static unsigned long zuletzt_ausgefuehrt__chaos_rueckwaerts = 0; // dann hier auch

    // Nach einer festen Zeit einen Spieler angreifen (auf einer Stelle hin und her)
    const unsigned int vorwaerts = 20000; // So viele ms wird zunächst normal gefahren (s.u.)
    const unsigned int rueckwaerts = 3000; // Dann wird auf der Stelle hin- und hergefahren
    const unsigned int hinundher = 3; // So oft wird hin- und hergefahren
    const float geschwindigkeit = 0.6f; // Geschwindigkeit beim Vor- und Rückwärtsfahren (bei Vollgas rutscht der Arm durch)
    
    unsigned long zeit_vergangen = millis() - zuletzt_ausgefuehrt__rauswurf;
    if (zeit_vergangen <= vorwaerts) {
      // Eine Zeit lang normal fahren
    } else if (zeit_vergangen <= vorwaerts + rueckwaerts) {
      // Dann auf einer Stelle hin- und herfahren
      const float oscillator = ((zeit_vergangen % ((rueckwaerts)/hinundher)) / ((static_cast<float>(rueckwaerts))/hinundher) - 0.5f) * 2; // oscillator läuft linear zwischen 1.0f und -1.0f hin- und her
      return (oscillator < 0 ? floor(oscillator) : ceil(oscillator)) * geschwindigkeit; // Rück- oder vorwärts mit oben eingestellter Geschwindigkeit
    } else {
      // Ein Zyklus ist rum, Timer neu starten
      zuletzt_ausgefuehrt__rauswurf = millis();
    }
    
    
    // Wie Spielmodus 2 fahren, nur ab und zu ein Stück rückwärts
    zeit_vergangen = millis() - zuletzt_ausgefuehrt__chaos_rueckwaerts;
    if (zeit_vergangen <= modus4_laenge_ges - modus4_laenge_rueckwaerts) {
      // Wird nur gebraucht, damit unten zur richtigen Zeit ins else gesprungen wird
    } else if (zeit_vergangen <= modus4_laenge_ges) {
      // Rückwärts fahren, zufällig schnell
      const float low = -1.0f;
      const float high = -0.3f;
      return low + static_cast <float> (rand()) /(static_cast <float> (RAND_MAX/(high-low)));
    } else {
      // Ein Zyklus ist rum, Timer neu starten und nächsten Anschlag planen
      zuletzt_ausgefuehrt__chaos_rueckwaerts = millis();
      modus4_laenge_ges = modus4_laenge_ges_min + (rand() % (int)(modus4_laenge_ges_max - modus4_laenge_ges_min + 1));
      modus4_laenge_rueckwaerts = modus4_laenge_rueckwaerts_min + (rand() % (int)(modus4_laenge_rueckwaerts_max - modus4_laenge_rueckwaerts_min + 1));
    }
    return spielmodi[2](); // Spielmodus 2
  },
  []() -> float {
    // TODO: Vorwärtsfahren und bremsen bis zum Anhalten, zufällig warten, dann Vollgas
    return 0.0f;

    // if: solange noch gebremst wird
    // else if: für eine zeit lang vollgas
    // else: von vorne
  },
  []() -> float {
    // Aus den anderen Spielmodi zufällig einen aussuchen
    Serial.println(rand() % (int)(anzahl_spielmodi)); // TODO: Das dann nur alle paar Sekunden
    return 0.0f; // spielmodi[(rand() % (int)(arr_len(spielmodi)));
  }
};

// Wechselt in den nächsten Spielmodus
void naechster_spielmodus() {
  // Aktuellen Modus und LEDs anhalten
  motor.geschwindigkeit_set(0.0f);
  alle_leds(0);
  delay(300);

  // Den nächsten Spielmodus auswählen und anzeigen
  spielmodus = (spielmodus + 1) % anzahl_spielmodi;
  alle_leds_blinken(spielmodus + 1, 120, 120); // LEDs so oft blinken lassen, wie hoch der Spielmodus ist

  delay(180);
  laufzeit_spielmodus_set(); // Nachhalten, wie lange der Spielmodus schon läuft
}


/* 
 *  setup, once, loop
 */

// Arduino starten
void setup() {
  // Serielle Verbindung fürs Debuggen aufbauen
  Serial.begin(9600);
  Serial.println("Ich bin jetzt an. (setup laeuft)");

  anzahl_spielmodi = arr_len(spielmodi);
  once();
}

// Aktionen, die einmalig nach dem Start ausgeführt werden
void once() {
  // LEDs beim Start aufleuchten lassen
  if (!debugging) { // Überspringen, wenn du nur am Rest rumschreibst
    for (Led led: leds) {
      led.on();
      delay(400);
    }
    delay(200);
    for (int j = 0; j < 3; j++) {
      alle_leds(1);
      delay(120);
      alle_leds(0);
      delay(120);
    }
    alle_leds(1);
    delay(600);
    leds[1].off();
    delay(300);
    leds[2].off();
    delay(100);
    leds[0].off();
  }
}

// Aktionen, die nach dem Start immer wieder ausgeführt werden
void loop() {
  static unsigned int led = 0;
  static boolean an = true;
  static Stoppuhr stoppuhr_ledlauf(200);
  static Button button(12);

  // Aktivität anzeigen: LEDs nacheinander umschalten
  if (stoppuhr_ledlauf.ist_abgelaufen()) {
    leds[led].status_set(an); // Die aktuelle LED umschalten
    led = (led + 1) % led_pins_count; // Die nächste LED auswählen

    // Wenn led == 0 ist, soll an gewechselt werden
    if (led == 0) {
      an = !an;
    }
    // Eine etwas langsamere, aber deutlich coolere Lösung ist die folgende:
    //   an = (led == 0) == !an;
    // Das funktioniert tatsächlich. :o Die Fälle:
    //   led == 0, an == 0:  an = 1 == 1  ==  1
    //   led == 1, an == 0:  an = 0 == 1  ==  0
    //   led == 0, an == 1:  an = 1 == 0  ==  0
    //   led == 1, an == 1:  an = 0 == 0  ==  1
    
    stoppuhr_ledlauf.reset(); // Neu stoppen
  }

  // Wurde der Knopf gedrückt?
  button.status_abfragen();
  if (button.wurde_gedrueckt()) {
    Serial.println("gedrueckt");
  } else if (button.wurde_losgelassen()) {
    Serial.println("losgelassen");
    naechster_spielmodus();
    
    // Die Blinksequenz neustarten
    an = true;
    led = 0;
    stoppuhr_ledlauf.reset();
  }

  // Geschwindigkeit je nach Spielmodus einstellen
  motor.geschwindigkeit_set(spielmodi[spielmodus]());
}
